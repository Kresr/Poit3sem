#include "stdafx.h" // Подключение стандартного заголовочного файла для предварительно скомпилированных заголовков.
#include "In.h" // Подключение заголовочного файла для ввода данных.
#include "Error.h" // Подключение заголовочного файла для обработки ошибок.

#define STRING_END_ZERO '\0' // Определение символа конца строки.
using namespace std; // Использование пространства имен std.

namespace In // Пространство имен для работы с вводом данных.
{
    IN getin(wchar_t infile[]) // Функция для чтения данных из файла.
    {
        IN in; // Создание структуры для хранения данных.
        in.size = 0; // Инициализация размера текста.
        in.lines = 1; // Инициализация счетчика строк.
        in.ignor = 0; // Инициализация счетчика игнорируемых символов.
        char* line = new char[IN_MAX_LEN_TEXT]; // Выделение памяти для строки.
        int cols = 0; // Инициализация счетчика столбцов.

        unsigned char* text = new unsigned char[IN_MAX_LEN_TEXT]; // Выделение памяти для текста.

        ifstream fin(infile); // Открытие файла для чтения.
        if (fin.fail()) // Проверка, удалось ли открыть файл.
            throw ERROR_THROW(110); // Если файл не открыт, выбрасываем ошибку 110.

        while (in.size < IN_MAX_LEN_TEXT) // Цикл чтения, пока размер текста меньше максимального.
        {
            char k; // Переменная для символа из файла.
            fin.get(k); // Чтение одного символа из файла.
            unsigned char uc = k; // Преобразование символа к unsigned char.

            if (fin.eof()) // Проверка конца файла.
            {
                text[in.size] = STRING_END_ZERO; // Завершаем текст символом конца строки.
                break; // Прерываем цикл.
            }
            if (in.code[uc] == in.T || in.code[uc] == in.D || in.code[uc] == in.O) // Если символ корректный (буква, цифра, специальный).
            {
                text[in.size] = uc; // Сохраняем символ в текст.
                in.size++; // Увеличиваем размер текста.
                cols++; // Увеличиваем количество столбцов.
            }
            else if (in.code[uc] == in.I) // Если символ игнорируемый.
            {
                in.ignor++; // Увеличиваем счетчик игнорируемых символов.
            }
            else if (in.code[uc] == in.F) // Если символ запрещенный.
            {
                throw ERROR_THROW_IN(111, in.lines, cols); // Выбрасываем ошибку с указанием строки и столбца.
            }
            else // В остальных случаях.
            {
                text[in.size] = in.code[uc]; // Преобразуем символ и добавляем в текст.
                in.size++; // Увеличиваем размер текста.
                cols++; // Увеличиваем количество столбцов.
            }
            if (uc == IN_CODE_ENDL) // Проверка на символ новой строки.
            {
                in.lines++; // Увеличиваем счетчик строк.
                cols = 0; // Сбрасываем счетчик столбцов.
            }
        }
        in.text = text; // Присваиваем текст в структуру.
        return in; // Возвращаем структуру с данными.
    }
}
